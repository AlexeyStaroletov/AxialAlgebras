### calculations in PC(eta)-axial algebra, where eta is not equal to -1, generated by three primitive axes a, b, and c

FF:=Rationals;

## order in the basis: a, b, c, ab, bc, ac, abc=a(bc), bac=b(ac), 
## alp=(a,b), bet=(b,c), gam=(a,c), psi =(a,bc) - all of them are equal to 1.

alp:=1; bet:=1; gam:=1; psi:=1;
eta:=Indeterminate(FF,"eta");;

F:=FunctionField(FF, 1);

z:=Identity(F);

a:=    z*[1,0,0,0,0,0,0,0];
b:=    z*[0,1,0,0,0,0,0,0];
c:=    z*[0,0,1,0,0,0,0,0];
ab:=   z*[0,0,0,1,0,0,0,0];
bc:=   z*[0,0,0,0,1,0,0,0];
ac:=   z*[0,0,0,0,0,1,0,0];
abc:=  z*[0,0,0,0,0,0,1,0];
bac:=  z*[0,0,0,0,0,0,0,1];

cab:= (eta + 1) * (ab + bc + ac) - eta * (a + b + c) - abc - bac;

L:=[a,b,c,ab,bc,ac,abc,bac];

mas:=[];   ### array for pairwise products of elements of L
for i in [1..8] do
  Add(mas, []);
  for j in [1..8] do
    Add(mas[i], []);
      for k in [1..8] do
        Add(mas[i][j], z*0);
od;od;od;

copy := function(i,j)    ### this function makes the product symmetric: mas[i][j] = mas[j][i]
  local k;
  for k in [1..8] do
    mas[j][i][k]:=mas[i][j][k];
  od;
end;

prod := function(u,v)   ### function which finds the product of two vectors u and v written with respect to L
  local i,j,k, ans;
  ans:=z * 0*a;
  for i in [1..8] do
  for j in [1..8] do
  for k in [1..8] do
    ans[k] := ans[k] + u[i]*v[j]*mas[i][j][k];
  od; od; od;
  return ans;
end;

### a*ax = (a,x)*(1-eta)/2*a-eta/2*x+(1+2*eta)/2*ax;

## a*a
mas[1][1] := a;
## a*b
mas[1][2] := ab;
copy(1,2);
## a*c
mas[1][3] := ac;
copy(1,3);
## b*b
mas[2][2] := b;
## b*c
mas[2][3] := bc;
copy(2,3);
## c*c
mas[3][3] := c;
## a*ab
mas[1][4] := (1+2*eta)/2*ab + (1-eta)/2*a - eta/2*b;
copy(1,4);
## a*bc
mas[1][5] := abc;
copy(1,5);
## a*ac
mas[1][6] :=  (1+2*eta)/2*ac + (1-eta)/2*a - eta/2*c;
copy(1,6);
## b*ab
mas[2][4] :=  (1+2*eta)/2*ab + (1-eta)/2*b - eta/2*a;
copy(2,4);
## b*bc
mas[2][5] :=  (1+2*eta)/2*bc + (1-eta)/2*b - eta/2*c;
copy(2,5);
## b*ac
mas[2][6] := bac;
copy(2,6);
## c*ab
mas[3][4] := cab;
copy(3,4);
## c*bc
mas[3][5] :=  (1+2*eta)/2*bc + (1-eta)/2*c - eta/2*b;
copy(3,5);
## c*ac
mas[3][6] :=  (1+2*eta)/2*ac + (1-eta)/2*c - eta/2*a;
copy(3,6);

## 1/4*( w(xy)*(1-2*eta)*a-eta*w(x)*y-eta*w(y)*x-xy+2*eta*w(x)*ay+2*eta*w(y)*ax-2*x*ay-2*y*ax)
## ab*ab  (ab,ab)=(a,a(ab)) = (a, -ab/2+alp*a+b/2) =-alp/2+alp^2+alp/2
mas[4][4] := 1/4*( (1-2*eta)*a + (-1-2*eta)*b + 4*eta*ab  + 4*prod(ab,b) );
## bc*bc
mas[5][5] := 1/4*( (1-2*eta)*b + (-1-2*eta)*c + 4*eta*bc  + 4*prod(bc,c) );
## ac*ac
mas[6][6] := 1/4*( (1-2*eta)*a + (-1-2*eta)*c + 4*eta*ac  + 4*prod(ac,c) );
## ab*ac
mas[4][6] := 1/4*( (1-2*eta)*a-eta*b-eta*c-bc + 2*eta*ab + 2*eta*ac + 2 * prod(b,ac) + 2 * prod(c, ab) );
copy(4,6);
## ab*bc = ba*bc
mas[4][5] := 1/4*( (1-2*eta)*b-eta*a-eta*c-ac + 2*eta*ab + 2*eta*bc + 2 * prod(a,bc) + 2 * prod(c, ab) );
copy(4,5);
## ac*bc = ca*cb
mas[5][6] := 1/4*( (1-2*eta)*c-eta*a-eta*b-ab + 2*eta*ac + 2*eta*bc + 2 * prod(a, bc) + 2 * prod(b, ac) );
copy(5,6);

### a*a(bc)
mas[1][7] := 1/2*((1-eta)*a-eta*bc+(1+2*eta)*abc);
copy(1,7);
### b*b(ac)
mas[2][8] := 1/2*((1-eta)*b-eta*ac+(1+2*eta)*bac);
copy(2,8);

### a*bac ?
# a*(bac+cab)=a*((eta+1)*(ab+bc+ac)-eta*(a+b+c)-abc);
tmp := prod(a, (eta+1)*(ab + bc + ac) - eta*(a+b+c) - abc);
# a*(bac-cab)=1/2*(bac-cab) + (eta-1/2) * (eta^2-eta) * (c_eta - b_eta);
c_eta := 1/(1-2*eta) * (a + c - 2*ac);
b_eta := 1/(1-2*eta) * (a + b - 2*ab);
tmp2 := 1/2*(bac - cab) + (eta-1/2) * (eta^2-eta) * (c_eta - b_eta);
mas[1][8] := 1/2*(tmp + tmp2);
copy(1,8);

### b*abc ?
# b*(abc+cab)=b*((eta+1)*(ab+bc+ac)-eta*(a+b+c)-bac);
tmp := prod(b, (eta+1)*(ab + bc + ac) - eta*(a+b+c) - bac);
# b*(abc-cab)=1/2*(abc-cab) + (eta-1/2) * (eta^2-eta) * (c_eta - a_eta);
c_eta:=1/(1-2*eta) * (b + c - 2*bc);
a_eta:=1/(1-2*eta) * (a + b - 2*ab);
tmp2:= 1/2*(abc - cab) + (eta-1/2) * (eta^2-eta) * (c_eta - a_eta);
mas[2][7] := 1/2*(tmp + tmp2);
copy(2,7);

### c*abc & c*bac
### first find c*cab;
tmp3:= 1/2*((1-eta)*c-eta*ab+(1+2*eta)*cab);
# c*(abc+bac)=c*((eta+1)*(ab+bc+ac)-eta*(a+b+c)-cab);
tmp := prod(c, (eta+1)*(ab + bc + ac) - eta*(a+b+c)) - tmp3;
# c*(abc-bac)=1/2*(abc-bac) + (eta-1/2) * (eta^2-eta) * (b_eta - a_eta);
b_eta:=1/(1-2*eta) * (b + c - 2*bc);
a_eta:=1/(1-2*eta) * (a + c - 2*ac);
tmp2:= 1/2*(abc - bac) + (eta-1/2) * (eta^2-eta) * (b_eta - a_eta);
mas[3][7] := 1/2*(tmp + tmp2);
copy(3,7);
mas[3][8] := 1/2*(tmp - tmp2);
copy(3,8);


## ab*abc
mas[4][7] := 1/4*( (1-2*eta)*a-eta*b-eta*bc-prod(b,bc) + 2*eta*ab + 2*eta*abc + 2 * prod(bc,ab) + 2 * prod(b, abc) );
copy(4,7);

## ab*bac = ba*bac
mas[4][8] := 1/4*( (1-2*eta)*b-eta*a-eta*ac-prod(a,ac) + 2*eta*ab + 2*eta*bac + 2 * prod(ac,ab) + 2 * prod(a, bac) );
copy(4,8);

## bc*bac
mas[5][8] := 1/4*( (1-2*eta)*b-eta*c-eta*ac-prod(c,ac) + 2*eta*bc + 2*eta*bac + 2 * prod(bc,ac) + 2 * prod(c, bac) );
copy(5,8);

## bc*abc
### first find bc*cab = cb*cab
tmp:=1/4*( (1-2*eta)*c-eta*b-eta*ab-prod(b,ab) + 2*eta*bc + 2*eta*cab + 2 * prod(bc,ab) + 2 * prod(b, cab) );
## now bc*abc
mas[5][7]:= prod(bc, (eta+1)*(ab + bc + ac)-eta*(a+b+c)) - prod(bc, bac) - tmp;
copy(5,7);

## ac*abc
mas[6][7] := 1/4*( (1-2*eta)*a-eta*c-eta*bc-prod(c,bc) + 2*eta*ac + 2*eta*abc + 2 * prod(bc,ac) + 2 * prod(c, abc) );
copy(6,7);

### ac*bac
### first find ac*cab = ca*cab
tmp:=1/4*( (1-2*eta)*c-eta*a-eta*ab-prod(a,ab) + 2*eta*ac + 2*eta*cab + 2 * prod(ac,ab) + 2 * prod(a, cab) );
## now ac*bac
mas[6][8]:= prod(ac, (eta+1)*(ab + bc + ac) - eta*(a+b+c)) - prod(ac, abc) - tmp;
copy(6,8);

### abc*abc;
mas[7][7] := 1/4*( (1-2*eta)*a-eta*bc-eta*bc-prod(bc,bc) + 2*eta*abc + 2*eta*abc + 2 * prod(bc,abc) + 2 * prod(bc, abc) );

### bac*bac;
mas[8][8] := 1/4*( (1-2*eta)*b-eta*ac-eta*ac-prod(ac,ac) + 2*eta*bac + 2*eta*bac + 2 * prod(ac,bac) + 2 * prod(ac, bac) );
 
### abc*bac   (abc+bac)^2= ((eta+1)*(ab+bc+ac) - eta*(a+b+c) - cab)^2  
### 2*abc*bac = ((eta+1)*(ab+bc+ac) - eta*(a+b+c))^2 - 2*cab*((eta+1)*(ab+bc+ac) - eta*(a+b+c))+cab^2-abc^2-bac^2
tmp:= (eta + 1)*(ab + bc + ac) - eta*(a + b + c);
### find cab^2
tmp2:= 1/4*( (1-2*eta)*c-eta*ab-eta*ab-prod(ab,ab) + 2*eta * cab + 2*eta * cab + 2 * prod(ab,cab) + 2 * prod(ab, cab) );
mas[7][8] := 1/2 * (prod(tmp, tmp) + tmp2 - 2*prod(cab, tmp) - mas[7][7] - mas[8][8]);
copy(7,8);

##### verify minimal polynomial for  ad_a, ad_b, ad_c

ad_a:=[mas[1][1], mas[1][2], mas[1][3], mas[1][4], mas[1][5], mas[1][6], mas[1][7], mas[1][8]];
 (ad_a-ad_a^0)*(ad_a-1/2*ad_a^0)*(ad_a-eta*ad_a^0);

ad_b:=[mas[2][1], mas[2][2], mas[2][3], mas[2][4], mas[2][5], mas[2][6], mas[2][7], mas[2][8]];
 (ad_b-ad_b^0)*(ad_b-1/2*ad_b^0)*(ad_b-eta*ad_b^0);

ad_c:=[mas[3][1], mas[3][2], mas[3][3], mas[3][4], mas[3][5], mas[3][6], mas[3][7], mas[3][8]];
 (ad_c-ad_c^0)*(ad_c-1/2*ad_c^0)*(ad_c-eta*ad_c^0);

### subspaces for ad(a) 

bas1:=NullspaceMat(ad_a-ad_a^0);     ### basis for A_1(a)
basm:=NullspaceMat(ad_a - eta * ad_a^0);  ### basis for A_eta(a)
bas1m:=[bas1[1], basm[1], basm[2], basm[3]]; ### basis for A_1(a)+A_eta(a)
base:=NullspaceMat(ad_a-1/2*ad_a^0); ### basis for A_{1/2}(a)
U1:=VectorSpace(F, z*bas1); ### A_1(a)
Um:=VectorSpace(F, z*basm); ### A_eta(a)
Ue:=VectorSpace(F, z*base);  ### A_{1/2}(a)
U1m:=VectorSpace(F, z*bas1m);  ### A_1(a)+A_eta(a)

### verification of the fusion rules for a

for i in base do
for j in base do
if not  eta^0*prod(i,j) in U1m then
   Print("Fail\n");
fi;
od;od;

for i in bas1m do
for j in base do
if not eta^0*prod(i,j) in Ue then
   Print("Fail\n");
fi;
od;od;

for i in basm do
for j in basm do
if not prod(i,j) in U1 then
   Print("Fail\n");
fi;
od;od;

### subspaces for ad(b) 

bas1:=NullspaceMat(ad_b-ad_b^0);    ### basis for A_1(b)
basm:=NullspaceMat(ad_b-eta*ad_b^0);  ### basis for A_eta(b)
bas1m:=[bas1[1], basm[1], basm[2], basm[3]];  ### basis for A_1(b)+A_eta(b)
base:=NullspaceMat(ad_b-1/2*ad_b^0);   ### basis for A_{1/2}(b)
U1:=VectorSpace(F, z*bas1);  ### A_1(b)
Um:=VectorSpace(F, z*basm);  ### A_eta(b)
Ue:=VectorSpace(F, z*base);  ### A_{1/2}(b) 
U1m:=VectorSpace(F, z*bas1m);  ### A_1(b)+A_eta(b)

### verification of the fusion rules for b

for i in base do
for j in base do
if not  prod(i,j) in U1m then
   Print("Fail\n");
fi;
od;od;

for i in bas1m do
for j in base do
if not prod(i,j) in Ue then
   Print("Fail\n");
fi;
od;od;

for i in basm do
for j in basm do
if not prod(i,j) in U1 then
   Print("Fail\n");
fi;
od;od;

### subspaces for ad(c) 

bas1:=NullspaceMat(ad_c-ad_c^0);  ### basis for A_1(c)
basm:=NullspaceMat(ad_c-eta*ad_c^0);  ### basis for A_eta(c)
bas1m:=[bas1[1], basm[1], basm[2], basm[3]];  ### basis for A_1(c)+A_eta(c) 
base:=NullspaceMat(ad_c-1/2*ad_c^0);  ### basis for A_{1/2}(c)
U1:=VectorSpace(F, z*bas1);   ### A_1(c)
Um:=VectorSpace(F, z*basm);   ### A_eta(c)
Ue:=VectorSpace(F, z*base);   ### A_{1/2}(c)
U1m:=VectorSpace(F, z*bas1m);  ### A_1(c)+A_eta(c)

### verification of the fusion rules for c

for i in base do
for j in base do
if not  prod(i,j) in U1m then
   Print("Fail\n");
fi;
od;od;

for i in bas1m do
for j in base do
if not prod(i,j) in Ue then
   Print("Fail\n");
fi;
od;od;

for i in basm do
for j in basm do
if not prod(i,j) in U1 then
   Print("Fail\n");
fi;
od;od;
