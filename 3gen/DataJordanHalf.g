##### this file contains calculation for axial algebras of Jordan type half generated by primitive axes a, b, and c

FF:=Rationals;
eta:=1/2;
alp:=Indeterminate(FF,"alp");;
bet:=Indeterminate(FF,"bet");;
gam:=Indeterminate(FF,"gam");;
phi:=Indeterminate(FF,"phi");;
F:=FunctionField(FF, 4);

#### the basis: a, b, c, ab, bc, ac, a(bc), b(ca), c(ab)
#### alp=(a,b), bet=(b,c), gam=(a,c), phi=(ab,c), where (,) is the Frobenius form

z:=alp^0;

#### mas will contain table of products 
#### fill products for a, b, and c by hands (first 3 rows of table of products)

mas :=[
#a
[[1*z,0*z,0*z,0*z,0*z,0*z,0*z,0*z,0*z], [0*z,0*z,0*z,1*z,0*z,0*z,0*z,0*z,0*z], [0*z,0*z,0*z,0*z,0*z,1*z,0*z,0*z,0*z], 
[alp-eta*alp,0*z,0*z,eta,0*z,0*z,0*z,0*z,0*z], [0*z,0*z,0*z,0*z,0*z,0*z,1*z,0*z,0*z], [gam-eta*gam,0*z,0*z,0*z,0*z,eta,0*z,0*z,0*z], 
[phi*(1-eta), 0*z,0*z,0*z,0*z,0*z,eta,0*z,0*z ], [alp*gam+1/2*eta*phi-2*eta*alp*gam, 0*z, 0*z, 1/2*eta*gam, 0*z, 1/2*eta*alp, 1/2*eta, 1/2*eta, -1/2*eta], [alp*gam+1/2*eta*phi-2*eta*alp*gam, 0*z, 0*z, 1/2*eta*gam, 0*z, 1/2*eta*alp, 1/2*eta, -1/2*eta, 1/2*eta]],
#b
[[0*z,0*z,0*z,1*z,0*z,0*z,0*z,0*z,0*z], [0*z,1*z,0*z,0*z,0*z,0*z,0*z,0*z,0*z], [0*z,0*z,0*z,0*z,1*z,0*z,0*z,0*z,0*z],
[0*z,alp-eta*alp,0*z,eta,0*z,0*z,0*z,0*z,0*z], [0*z,bet-eta*bet,0*z,0*z,eta,0*z,0*z,0*z,0*z], [0*z,0*z,0*z,0*z,0*z,0*z,0*z,1*z,0*z], 
[0*z, alp*bet+1/2*eta*phi-2*eta*alp*bet, 0*z, 1/2*eta*bet, 1/2*eta*alp, 0*z, 1/2*eta, 1/2*eta, -1/2*eta], [0*z, phi*(1-eta), 0*z,0*z,0*z,0*z,0*z,eta,0*z], [0*z, alp*bet+1/2*eta*phi-2*eta*alp*bet, 0*z, 1/2*eta*bet, 1/2*eta*alp, 0*z, -1/2*eta, 1/2*eta, 1/2*eta]],
#c
[[0*z,0*z,0*z,0*z,0*z,1*z,0*z,0*z,0*z], [0*z,0*z,0*z,0*z,1*z,0*z,0*z,0*z,0*z], [0*z,0*z,1*z,0*z,0*z,0*z,0*z,0*z,0*z], 
[0*z,0*z,0*z,0*z,0*z,0*z,0*z,0*z,1*z], [0*z,0*z,bet-eta*bet,0*z,eta,0*z,0*z,0*z,0*z], [0*z,0*z,gam-eta*gam,0*z,0*z,eta,0*z,0*z,0*z], 
[0*z, 0*z, bet*gam+1/2*eta*phi-2*eta*bet*gam,0*z,1/2*eta*gam,1/2*eta*bet,1/2*eta, -1/2*eta, 1/2*eta], [0*z, 0*z, bet*gam+1/2*eta*phi-2*eta*bet*gam,0*z,1/2*eta*gam,1/2*eta*bet,-1/2*eta, 1/2*eta, 1/2*eta], [0*z, 0*z, phi*(1-eta), 0*z,0*z,0*z,0*z,0*z,eta]]
];


empty:=[0*z,0*z,0*z,0*z,0*z,0*z,0*z,0*z,0*z];

for i in [4..9] do
Add(mas, []);
for k in [1..9] do
Add(mas[i], []);
for j in empty do
    Add(mas[i][k], j);
od;
od;
od;

copy := function(i,j)
local k;

for k in [1..9] do
    mas[j][i][k]:=mas[i][j][k];
od;

end;

for i in [1..3] do
for j in [1..9] do
    copy(i,j);
od;od;

########################################################################
### prod evaluates products of two vectors u and v using the array mas
########################################################################
prod := function(u,v)

local i,j,k, ans;

ans:=[0*z,0*z,0*z,0*z,0*z,0*z,0*z,0*z,0*z];

for i in [1..9] do
for j in [1..9] do
for k in [1..9] do

ans[k] := ans[k] + u[i]*v[j]*mas[i][j][k];

od;
od;
od;

return ans;

end;

a:=z*[1,0,0,0,0,0,0,0,0];
b:=z*[0,1,0,0,0,0,0,0,0];
c:=z*[0,0,1,0,0,0,0,0,0];
ab:=z*[0,0,0,1,0,0,0,0,0];
bc:=z*[0,0,0,0,1,0,0,0,0];
ac:=z*[0,0,0,0,0,1,0,0,0];
abc:=z*[0,0,0,0,0,0,1,0,0];
bac:=z*[0,0,0,0,0,0,0,1,0];
cab:=z*[0,0,0,0,0,0,0,0,1];

###############################################
### now we fill other elements of mas
###############################################

## ab*ab = ab*(ab-eta*b)
mas[4][4] := prod(a, prod(b, ab - eta*b)) + eta*prod(b,ab);

## ab*bc = ba*(bc-eta*c)
mas[4][5] := prod(b, prod(a, bc - eta*c)) + eta*cab;

## ab*ac = ab*(ac-eta*c)
mas[4][6] := prod(a, prod(b, ac - eta*c)) + eta*cab;

copy(4,5); copy(4,6);

## bc*bc = bc*(bc -eta*c)
mas[5][5]:= prod(b, prod(c, bc - eta*c)) + eta*prod(c,bc);

## bc*ac = cb*(ac -eta*a)
mas[5][6] := prod(c, prod(b, ac - eta*a )) + eta*abc;
copy(5,6);

## ac*ac
mas[6][6] := prod(a, prod(c, ac - eta*c)) + eta*prod(c,ac);


### ab*a(bc) = ab*(abc - eta*bc)
mas[4][7] := prod(a, prod(b, abc - eta*bc)) + eta*prod(ab, bc);

### ab*b(ac) = ba*(bac - eta*ac)
mas[4][8] := prod(b, prod(a, bac - eta*ac)) + eta*prod(ab, ac);

### ab*c(ab) + ab*b(ac) = a*(b*( cab+bac - eta*bc -eta*gam*b - eta*alp*c )) + ab*(eta*bc +eta*gam*b +eta*alp*c);
mas[4][9] := - mas[4][8] + prod(a, prod(b, cab+bac - eta*bc -eta*gam*b - eta*alp*c)) + prod(ab, eta*bc +eta*gam*b +eta*alp*c);
copy(4,7); copy(4,8); copy(4,9);

### bc*b(ac)
mas[5][8] := prod(b, prod(c, bac -eta*ac)) + eta*prod(bc, ac);

### bc*c(ab)
mas[5][9] := prod(c, prod(b, cab -eta*ab)) + eta*prod(bc, ab);

### bc*abc = bc*(abc+cab)-bc*cab
mas[5][7] := -mas[5][9] + prod(b, prod(c, abc+cab - eta*ac - eta*bet*a -eta*alp*c)) + prod(bc, eta*ac + eta*bet*a +eta*alp*c);

copy(5,7); copy(5,8); copy(5,9);

### ac*a(bc)
mas[6][7] := prod(a, prod(c, abc -eta*bc)) + eta*prod(ac, bc);

### ac*c(ab)
mas[6][9] := prod(c, prod(a, cab -eta*ab)) + eta*prod(ac, ab);

### ac*b(ac) + ac*cab
mas[6][8] := -mas[6][9] + prod(a, prod(c, bac+cab - eta*bc - eta*gam*b - eta*alp*c )) + prod(ac, eta*bc + eta*gam*b + eta*alp*c);

copy(6,7); copy(6,8); copy(6,9);

### abc*abc = abc*(abc - eta*bc) + eta*abc*bc
mas[7][7] := prod(a, prod(bc, abc - eta*bc)) + eta*prod(bc, abc);

### bac*bac = bac*(bac - eta*ac) + eta*bac*ac
mas[8][8] := prod(b, prod(ac, bac - eta*ac)) + eta*prod(ac, bac);


### cab*cab = cab*(cab - eta*ab) + eta*cab*ab
mas[9][9] := prod(c, prod(ab, cab - eta*ab)) + eta*prod(ab, cab);

## xyxz=x(y+z) etc
xyxz:=prod(a, prod(bc, bac + cab - eta*bc -eta*gam*b - eta*alp*c)) + prod(abc, eta*bc + eta*gam*b + eta*alp*c);
yxyz:=prod(b, prod(ac, abc + cab - eta*ac -eta*bet*a - eta*alp*c)) + prod(bac, eta*ac + eta*bet*a + eta*alp*c);
zxzy:=prod(c, prod(ab, abc + bac - eta*ab -eta*bet*a - eta*gam*b)) + prod(cab, eta*ab + eta*bet*a + eta*gam*b);

mas[7][8]:=1/2*(xyxz + yxyz - zxzy);
mas[7][9]:=1/2*(xyxz + zxzy - yxyz);
mas[8][9]:=1/2*(yxyz + zxzy - xyxz);

copy(7,8); copy(7,9); copy(8,9);

########################################
## write down explicitly eigenspaces

### A0-space
zero:=z*[0,0,0,0,0,0,0,0,0];
prod(a, ab - alp* a/2 - b/2) = zero;
prod(a, ac - gam* a/2 - c/2) = zero;
prod(a, abc - 1/2*bc - phi/2*a) = zero;
prod(a, bac +cab - 1/2*bc - 1/2*alp*c - 1/2*gam*b - 1/2*phi*a) = zero;

### Aeta-space
prod(a, bac - cab) = eta*(bac - cab);
prod(a, ab - alp*a) = eta*(ab - alp*a);
prod(a, ac - gam*a) = eta*(ac - gam*a);
prod(a, abc - phi * a) = eta * (abc - phi*a);

##### fill bases for eigenspaces

bas1:=[a];
bas0:=[ab - alp* a/2 - b/2, ac - gam* a/2 - c/2, abc - 1/2*bc - phi/2*a, bac +cab - 1/2*bc - 1/2*alp*c - 1/2*gam*b - 1/2*phi*a];
bas10:=[a, ab - alp* a/2 - b/2, ac - gam* a/2 - c/2, abc - 1/2*bc - phi/2*a, bac +cab - 1/2*bc - 1/2*alp*c - 1/2*gam*b - 1/2*phi*a];
base:=[bac - cab, ab - alp*a, ac - gam*a, abc - phi * a];

# basis for b
#bas1:=[b];
#bas0:=[ab - alp* b/2 - a/2, bc - bet*b/2 - c/2, bac - 1/2*ac - phi/2*b, abc +cab - 1/2*ac - 1/2*alp*c - 1/2*bet*a - 1/2*phi*b];
#bas10:=[b, ab - alp * b/2 - a/2, bc - bet*b/2 - c/2, bac - 1/2*ac - phi/2*b, abc +cab - 1/2*ac - 1/2*alp*c - 1/2*bet*a - 1/2*phi*b];
#base:=[cab-abc, ab - alp*b, bc - bet*b, bac - phi * b];

# basis for c
#bas1:=[c];
#bas0:=[ac - gam* c/2 - a/2, bc - bet*c/2 - b/2, cab - 1/2*ab - phi/2*c, abc+bac - 1/2*ab - 1/2*gam*b - 1/2*bet*a - 1/2*phi*c];
#bas10:=[c, ac - gam* c/2 - a/2, bc - bet*c/2 - b/2, cab - 1/2*ab - phi/2*c, abc+bac - 1/2*ab - 1/2*gam*b - 1/2*bet*a - 1/2*phi*c];
#base:=[abc-bac, ac - gam*c, bc - bet*c, cab - phi * c];

U0:=VectorSpace(F, bas0);
U1:=VectorSpace(F, bas1);
U10:=VectorSpace(F, bas10);
Ue:=VectorSpace(F, base);

#### verification of the fusion rules

for i in base do
for j in base do
if not  prod(i,j) in U10 then
   Print("Fail\n");
fi;
od;od;

for i in bas10 do
for j in base do
if not prod(i,j) in Ue then
   Print("Fail\n");
fi;
od;od;

for i in bas0 do
for j in bas0 do
if not prod(i,j) in U0 then
   Print("Fail\n");
fi;
od;od;

##### basis of the 9-dimensional algebra

L:=[a, b, c, ab, bc, ac, abc, bac, cab];

#### first 3 rows of Gram matrix are entered by hands

Gram := [
[1, alp, gam, alp, phi, gam, phi, 1/2*gam*alp + 1/2*phi, 1/2*gam*alp + 1/2*phi],
[alp, 1, bet, alp, bet, phi, 1/2*alp*bet + 1/2*phi, phi, 1/2*alp*bet + 1/2*phi],
[gam, bet, 1, phi, bet, gam, 1/2*bet*gam + 1/2*phi, 1/2*bet*gam + 1/2*phi, phi]
];

##### now fill other elements of the Gram matrix

for i in [4..9] do
    Add(Gram, []);
    for j in [1..9] do
        Add(Gram[i], 0*z);
    od;
od;



for i in [1..9] do
tmp:=prod(b, L[i]);
for j in [1..9] do
    Gram[4][i]:=Gram[4][i]+Gram[1][j]*tmp[j];
    Gram[5][i]:=Gram[5][i]+Gram[3][j]*tmp[j];
od;
od;

for i in [1..9] do
tmp:=prod(c, L[i]);
for j in [1..9] do
    Gram[6][i]:=Gram[6][i]+Gram[1][j]*tmp[j];
    Gram[9][i]:=Gram[9][i]+Gram[4][j]*tmp[j];
od;
od;

for i in [1..9] do
tmp:=prod(a, L[i]);
for j in [1..9] do
    Gram[7][i]:=Gram[7][i]+Gram[5][j]*tmp[j];
od;
od;

for i in [1..9] do
tmp:=prod(b, L[i]);
for j in [1..9] do
    Gram[8][i]:=Gram[8][i]+Gram[6][j]*tmp[j];
od;
od;

### det Gram = (alp+bet+gam-2*phi-1)^6*(alp*bet*gam-phi^2)^3

###################################################################

### matrices of Miyamoto involutions

taua:=z* [ [ 1, 0, 0, 0, 0, 0, 0, 0, 0 ], [ 4*alp, 1, 0, -4, 0, 0, 0, 0, 0 ], [ 4*gam, 0, 1, 0, 0, -4, 0, 0, 0 ], [ 2*alp, 0, 0, -1, 0, 0, 0, 0, 0 ], 
  [ 4*phi, 0, 0, 0, 1, 0, -4, 0, 0 ], [ 2*gam, 0, 0, 0, 0, -1, 0, 0, 0 ], [ 2*phi, 0, 0, 0, 0, 0, -1, 0, 0 ], [ 2*alp*gam+phi, 0, 0, -gam, 0, -alp, -1, 0, 1 ], [ 2*alp*gam+phi, 0, 0, -gam, 0, -alp, -1, 1, 0 ] ];
 
taub:=z*  [ [ 1, 4*alp, 0, -4, 0, 0, 0, 0, 0 ], [ 0, 1, 0, 0, 0, 0, 0, 0, 0 ], [ 0, 4*bet, 1, 0, -4, 0, 0, 0, 0 ], [ 0, 2*alp, 0, -1, 0, 0, 0, 0, 0 ], 
  [ 0, 2*bet, 0, 0, -1, 0, 0, 0, 0 ], [ 0, 4*phi, 0, 0, 0, 1, 0, -4, 0 ], [ 0, 2*alp*bet+phi, 0, -bet, -alp, 0, 0, -1, 1 ], [ 0, 2*phi, 0, 0, 0, 0, 0, -1, 0 ], [ 0, 2*alp*bet+phi, 0, -bet, -alp, 0, 1, -1, 0 ] ];

tauc:=z* [ [ 1, 0, 4*gam, 0, 0, -4, 0, 0, 0 ], [ 0, 1, 4*bet, 0, -4, 0, 0, 0, 0 ], [ 0, 0, 1, 0, 0, 0, 0, 0, 0 ], [ 0, 0, 4*phi, 1, 0, 0, 0, 0, -4 ], 
  [ 0, 0, 2*bet, 0, -1, 0, 0, 0, 0 ], [ 0, 0, 2*gam, 0, 0, -1, 0, 0, 0 ], [ 0, 0, 2*bet*gam+phi, 0, -gam, -bet, 0, 1, -1 ], [ 0, 0, 2*bet*gam+phi, 0, -gam, -bet, 1, 0, -1 ], [ 0, 0, 2*phi, 0, 0, 0, 0, 0, -1 ] ];
