######## here we fill the table of products of a primitive axial algebra of Jordan type eta,
######## which is generated by three primitive axes a, b, and c
######## we denote alp=(a,b), bet=(b,c), gam=(a,c) and phi=(a,bc), 
######## where (,) is the Frobenius form such that (a,a)=(b,b)=(c,c)=1
######## Note that there are additional equalities that are not assumed:
######## 0=alp*(eta-1/2)*(bet-gam)*(eta-2*alp)
######## 0=bet*(eta-1/2)*(gam-alp)*(eta-2*bet)
######## 0=gam*(eta-1/2)*(alp-bet)*(eta-2*gam)  
########

FF:=Rationals;
eta:=Indeterminate(Rationals,"eta");;
alp:=Indeterminate(Rationals,"alp");;
bet:=Indeterminate(Rationals,"bet");;
gam:=Indeterminate(Rationals,"gam");;
phi:=Indeterminate(Rationals,"phi");;
F:=FunctionField(FF,5);

## the basis: a, b, c, ab, bc, ac, a(bc), b(ca), c(ab)
## alp=(a,b), bet=(b,c), gam=(a,c), phi=(ab,c)

z:=alp^0;

### fill products for a, b, and c by hands (first 3 rows of table of products)

mas :=z*[
#a
[[1,0,0,0,0,0,0,0,0], [0,0,0,1,0,0,0,0,0], [0,0,0,0,0,1,0,0,0], 
[alp-eta*alp,0,0,eta,0,0,0,0,0], [0,0,0,0,0,0,1,0,0], [gam-eta*gam,0,0,0,0,eta,0,0,0], 
[phi*(1-eta), 0,0,0,0,0,eta,0,0 ], [alp*gam+1/2*eta*phi-2*eta*alp*gam, 0, 0, 1/2*eta*gam, 0, 1/2*eta*alp, 1/2*eta, 1/2*eta, -1/2*eta], [alp*gam+1/2*eta*phi-2*eta*alp*gam, 0, 0, 1/2*eta*gam, 0, 1/2*eta*alp, 1/2*eta, -1/2*eta, 1/2*eta]],
#b
[[0,0,0,1,0,0,0,0,0], [0,1,0,0,0,0,0,0,0], [0,0,0,0,1,0,0,0,0],
[0,alp-eta*alp,0,eta,0,0,0,0,0], [0,bet-eta*bet,0,0,eta,0,0,0,0], [0,0,0,0,0,0,0,1,0], 
[0, alp*bet+1/2*eta*phi-2*eta*alp*bet, 0, 1/2*eta*bet, 1/2*eta*alp, 0, 1/2*eta, 1/2*eta, -1/2*eta], [0, phi*(1-eta), 0,0,0,0,0,eta,0], [0, alp*bet+1/2*eta*phi-2*eta*alp*bet, 0, 1/2*eta*bet, 1/2*eta*alp, 0, -1/2*eta, 1/2*eta, 1/2*eta]],
#c
[[0,0,0,0,0,1,0,0,0], [0,0,0,0,1,0,0,0,0], [0,0,1,0,0,0,0,0,0], 
[0,0,0,0,0,0,0,0,1], [0,0,bet-eta*bet,0,eta,0,0,0,0], [0,0,gam-eta*gam,0,0,eta,0,0,0], 
[0, 0, bet*gam+1/2*eta*phi-2*eta*bet*gam,0,1/2*eta*gam,1/2*eta*bet,1/2*eta, -1/2*eta, 1/2*eta], [0, 0, bet*gam+1/2*eta*phi-2*eta*bet*gam,0,1/2*eta*gam,1/2*eta*bet,-1/2*eta, 1/2*eta, 1/2*eta], [0, 0, phi*(1-eta), 0,0,0,0,0,eta]]
];


empty:=z*[0,0,0,0,0,0,0,0,0];

for i in [4..9] do
Add(mas, []);
for k in [1..9] do
Add(mas[i], []);
for j in empty do
    Add(mas[i][k], j);
od;
od;
od;

copy := function(i,j)
local k;

for k in [1..9] do
    mas[j][i][k]:=mas[i][j][k];
od;

end;


for i in [1..3] do
for j in [1..9] do
    copy(i,j);
od;od;

########################################################################
### prod evaluates products of two vectors u and v using the array mas
########################################################################

prod := function(u,v)

local i,j,k, ans;

ans:= z * [0,0,0,0,0,0,0,0,0];

for i in [1..9] do
for j in [1..9] do
for k in [1..9] do

ans[k] := ans[k] + u[i]*v[j]*mas[i][j][k];

od;
od;
od;

return ans;

end;

a:=z*[1,0,0,0,0,0,0,0,0];
b:=z*[0,1,0,0,0,0,0,0,0];
c:=z*[0,0,1,0,0,0,0,0,0];
ab:=z*[0,0,0,1,0,0,0,0,0];
bc:=z*[0,0,0,0,1,0,0,0,0];
ac:=z*[0,0,0,0,0,1,0,0,0];
abc:=z*[0,0,0,0,0,0,1,0,0];
bac:=z*[0,0,0,0,0,0,0,1,0];
cab:=z*[0,0,0,0,0,0,0,0,1];

############################


## ab*ab = ab*(ab-eta*b)
mas[4][4] := prod(a, prod(b, ab - eta*b)) + eta*prod(b,ab);

## ab*bc = ba*(bc-eta*c)
mas[4][5] := prod(b, prod(a, bc - eta*c)) + eta*cab;

## ab*ac = ab*(ac-eta*c)
mas[4][6] := prod(a, prod(b, ac - eta*c)) + eta*cab;

copy(4,5); copy(4,6);

## bc*bc = bc*(bc -eta*c)
mas[5][5]:= prod(b, prod(c, bc - eta*c)) + eta*prod(c,bc);

## bc*ac = cb*(ac -eta*a)
mas[5][6] := prod(c, prod(b, ac - eta*a )) + eta*abc;
copy(5,6);

## ac*ac
mas[6][6] := prod(a, prod(c, ac - eta*c)) + eta*prod(c,ac);


### ab*a(bc) = ab*(abc - eta*bc)
mas[4][7] := prod(a, prod(b, abc - eta*bc)) + eta*prod(ab, bc);

### ab*b(ac) = ba*(bac - eta*ac)
mas[4][8] := prod(b, prod(a, bac - eta*ac)) + eta*prod(ab, ac);

### ab*c(ab) + ab*b(ac) = a*(b*( cab+bac - eta*bc -eta*gam*b - eta*alp*c )) + ab*(eta*bc +eta*gam*b +eta*alp*c);
mas[4][9] := - mas[4][8] + prod(a, prod(b, cab+bac - eta*bc -eta*gam*b - eta*alp*c)) + prod(ab, eta*bc +eta*gam*b +eta*alp*c);
copy(4,7); copy(4,8); copy(4,9);

### bc*b(ac)
mas[5][8] := prod(b, prod(c, bac -eta*ac)) + eta*prod(bc, ac);

### bc*c(ab)
mas[5][9] := prod(c, prod(b, cab -eta*ab)) + eta*prod(bc, ab);

### bc*abc = bc*(abc+cab)-bc*cab
mas[5][7] := -mas[5][9] + prod(b, prod(c, abc+cab - eta*ac - eta*bet*a -eta*alp*c)) + prod(bc, eta*ac + eta*bet*a +eta*alp*c);

copy(5,7); copy(5,8); copy(5,9);

### ac*a(bc)
mas[6][7] := prod(a, prod(c, abc -eta*bc)) + eta*prod(ac, bc);

### ac*c(ab)
mas[6][9] := prod(c, prod(a, cab -eta*ab)) + eta*prod(ac, ab);

### ac*b(ac) + ac*cab
mas[6][8] := -mas[6][9] + prod(a, prod(c, bac+cab - eta*bc - eta*gam*b - eta*alp*c )) + prod(ac, eta*bc + eta*gam*b + eta*alp*c);

copy(6,7); copy(6,8); copy(6,9);

### abc*abc = abc*(abc - eta*bc) + eta*abc*bc
mas[7][7] := prod(a, prod(bc, abc - eta*bc)) + eta*prod(bc, abc);

### bac*bac = bac*(bac - eta*ac) + eta*bac*ac
mas[8][8] := prod(b, prod(ac, bac - eta*ac)) + eta*prod(ac, bac);

### cab*cab = cab*(cab - eta*ab) + eta*cab*ab
mas[9][9] := prod(c, prod(ab, cab - eta*ab)) + eta*prod(ab, cab);

## xyxz=x(y+z) etc
xyxz:=prod(a, prod(bc, bac + cab - eta*bc -eta*gam*b - eta*alp*c)) + prod(abc, eta*bc + eta*gam*b + eta*alp*c);
yxyz:=prod(b, prod(ac, abc + cab - eta*ac -eta*bet*a - eta*alp*c)) + prod(bac, eta*ac + eta*bet*a + eta*alp*c);
zxzy:=prod(c, prod(ab, abc + bac - eta*ab -eta*bet*a - eta*gam*b)) + prod(cab, eta*ab + eta*bet*a + eta*gam*b);

mas[7][8]:=1/2*(xyxz + yxyz - zxzy);
mas[7][9]:=1/2*(xyxz + zxzy - yxyz);
mas[8][9]:=1/2*(yxyz + zxzy - xyxz);

copy(7,8); copy(7,9); copy(8,9);

############

####### verification of the fusion rules (do not foget about additional equalities for alp, bet, gam and phi)

### A0-space
zero:=z*[0,0,0,0,0,0,0,0,0];
prod(a, ab - alp*(1-eta)*a - eta*b) = zero;
prod(a, ac - gam*(1-eta)*a - eta*c) = zero;
prod(a, abc - eta*bc - phi*(1-eta)*a) = zero;
prod(a, bac + cab - eta*bc - eta*alp*c - eta*gam*b - (2*alp*gam+eta*phi-4*eta*alp*gam)*a) = zero;

### Aeta-space
prod(a, bac - cab) = eta*(bac - cab);
prod(a, ab - alp*a) = eta*(ab - alp*a);
prod(a, ac - gam*a) = eta*(ac - gam*a);
prod(a, abc - phi * a) = eta * (abc - phi*a);

bas1:=[a];
bas0:=[ab - alp*(1-eta)*a - eta*b,ac - gam*(1-eta)*a - eta*c,abc - eta*bc - phi*(1-eta)*a,bac + cab - eta*bc - eta*alp*c - eta*gam*b - (2*alp*gam+eta*phi-4*eta*alp*gam)*a];
bas10:=[a, ab - alp*(1-eta)*a - eta*b,ac - gam*(1-eta)*a - eta*c,abc - eta*bc - phi*(1-eta)*a,bac + cab - eta*bc - eta*alp*c - eta*gam*b - (2*alp*gam+eta*phi-4*eta*alp*gam)*a];
base:=[bac - cab, ab - alp*a, ac - gam*a, abc - phi * a];

U0:=VectorSpace(F, bas0);
U1:=VectorSpace(F, bas1);
U10:=VectorSpace(F, bas10);
Ue:=VectorSpace(F, base);

for i in base do
for j in base do
if not  prod(i,j) in U10 then
   Print("Fail\n");
fi;
od;od;

for i in bas10 do
for j in base do
if not prod(i,j) in Ue then
   Print("Fail\n");
fi;
od;od;

for i in bas0 do
for j in bas0 do
if not prod(i,j) in U0 then
   Print("Fail\n");
fi;
od;od;

